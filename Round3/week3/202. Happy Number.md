```
μ‘μ„±μ: μ„μΆ…μ›
λ‚ μ§: 2023. 05.17
```

# 202. Happy Number 

[LeetCode λ¬Έμ  λ§ν¬](https://leetcode.com/problems/happy-number/)

## λ¬Έμ  λ‚΄μ©

Happy numberλ” κ° μλ¦Ώμμ μ κ³±ν•©μ„ λ°λ³µμ μΌλ΅ κ³„μ‚°ν•μ—¬ λ‚μ¤λ” μμ…λ‹λ‹¤. 1μ΄ λ‚μ¬ κ²½μ° `true`λ¥Ό λ°ν™ν•λ©°, κ·Έλ ‡μ§€ μ•μΌλ©΄ `false`λ¥Ό λ°ν™ν•©λ‹λ‹¤.


## ν’€μ΄ κ³Όμ •

1. μ–‘μ μ •μλ¥Ό μ…λ ¥λ°›μ•„ ν•΄λ‹Ή μμ κ° μλ¦¬μμ μ κ³±μ„ λ”ν• κ²°κ³Όλ¥Ό λ°ν™ν•λ” ν•¨μλ¥Ό κµ¬ν„ν•©λ‹λ‹¤.
2. λ‘ κ°μ λ³€μ `slow`μ™€ `fast`λ¥Ό μ„ μ–Έν•©λ‹λ‹¤. `slow`μ—λ” ν•¨μλ¥Ό 1λ²μ”© μ‹¤ν–‰ν• κ²°κ³Όλ¥Ό λ€μ…ν•κ³ , `fast`μ—λ” ν•¨μλ¥Ό 2λ²μ”© μ‹¤ν–‰ν• κ²°κ³Όλ¥Ό λ€μ…ν•©λ‹λ‹¤.
3. `fast`κ°€ 1μ΄λ©΄ `true`λ¥Ό λ°ν™ν•©λ‹λ‹¤.
4. `slow`μ™€ `fast`κ°€ κ°™μ§€ μ•κ±°λ‚, `fast`κ°€ 1μ΄ μ•„λ‹ κ²½μ° λ£¨ν”„λ¥Ό μ‹¤ν–‰ν•©λ‹λ‹¤.
5. λ£¨ν”„κ°€ μΆ…λ£λλ©΄ `fast`λ¥Ό λ°ν™ν•©λ‹λ‹¤.

## Floyd's Cycle Detection (ν”λ΅μ΄λ“ μν™ κ°μ§€ μ•κ³ λ¦¬μ¦)

- λ‘ κ°μ ν¬μΈν„°λ¥Ό μ‚¬μ©ν•μ—¬ ν•λ‚μ ν¬μΈν„°λ” ν• λ²μ— ν• μΉΈμ”©, λ‹¤λ¥Έ ν¬μΈν„°λ” ν• λ²μ— λ‘ μΉΈμ”© μ›€μ§μ΄λ©΄μ„ μν™μ„ νƒμ§€
- μ‹κ°„ λ³µμ΅λ„ : O(n)
- κ³µκ°„ λ³µμ΅λ„ : λ‚®μ
- ν•΄μ‹ν…μ΄λΈ”μ„ μ΄μ©ν•΄μ„ μν™μ—¬λ¶€λ¥Ό κ²€μ‚¬ν•λ” λ°©λ²•λ„ μμ

## Quiz

### Q1. Rustμ `λ„¤μ΄λ° κ·μΉ™(naming convention)`μ€ λ¬΄μ—‡μΈκ°€μ”?
1. `CamelCase`
2. `snake_case`
3. `other`

### Q2. `u32`λ” μ–΄λ–¤ λ²”μ„μ κ°’μ„ λ‚νƒ€λ‚Ό μ μλ‚μ”?
1. `1 ~ 2^32-1`
2. `0 ~ 2^32-1`
3. `-2^32-1 ~ 2^32-1`

### Q3. π™ `Self::`λ¥Ό μ•„μ‹­λ‹κΉ?

### Q4. Rustμ—μ„ μ‚¬μ©λλ” `μ—°μ‚°μ`λ” λ¬΄μ—‡μΈκ°€μ”?
1. `**`
2. `&mut`
3. `===`

     
## CODE

### rust
```rust
// implμ€ κµ¬μ΅°μ²΄, νΈλ μ΄νΈ, μ—΄κ±°ν• λ“±μ Rust μ ν•μ„ κµ¬ν„
impl Solution {
    // pubμ€ ν•¨μκ°€ λ‹¤λ¥Έ λ¨λ“μ—μ„ μ‚¬μ©λ  μ μλ„λ΅ κ³µκ°λ κ²ƒ
    // i32μ€ integerμ 32bitλ¥Ό μλ―Έ, -2^31μ—μ„ 2^31-1κΉμ§€μ κ°’
    pub fn is_happy(number: i32) -> bool {
        // let ν‚¤μ›λ“λ¥Ό μ‚¬μ©ν•μ—¬ λ³€μ μ„ μ–Έ
        // mutμ€ λ³€μκ°€ κ°€λ³€(mutable)μ„μ„ μλ―Έ
        let mut slow = number;
        // Self::λ” ν„μ¬ νƒ€μ… λ‚΄μ—μ„ μ •μλ λ‹¤λ¥Έ λ©”μ„λ“λ¥Ό νΈμ¶ν•κΈ° μ„ν•΄ μ‚¬μ© [μ΄ν•΄λ„ λ¶€μ΅±]
        let mut fast = Self::get_next_happy(number);

        // μ•κ³ λ¦¬μ¦ ν•΄μ„μ„ μ„ν• get_next_happy ν•¨μ λ™μ‘ νμ
        let mut slow_n = 0;
        let mut fast_n = 1;

        // fastκ°€ 1μ΄ μ•„λ‹κ±°λ‚, slowμ™€ fastκ°€ κ°™μ§€ μ•μ€ κ²½μ° λ£¨ν”„ μ‹¤ν–‰
        while fast != 1 && slow != fast {
            slow = Self::get_next_happy(slow);
            fast = Self::get_next_happy(Self::get_next_happy(fast));

            slow_n += 1; 
            fast_n += 2;
            println!("Happy slow_n:{} fast_n:{}", slow_n, fast_n);
        }

        // ν•¨μ λ¦¬ν„΄ κ°’(bool) μ΅°κ±΄
        fast == 1
    }

    // μ–‘μ μ •μλ¥Ό μ…λ ¥λ°›μ•„ ν•΄λ‹Ή μμ κ° μλ¦¬μμ μ κ³±μ„ λ”ν• κ²°κ³Όλ¥Ό λ°ν™ν•λ” ν•¨μ
    fn get_next_happy(mut number: i32) -> i32 {
        let mut sum = 0;
        while number > 0 {
            let digit = number % 10;
            sum += digit * digit;
            number /= 10;
        }
        sum
    }
}
```


```rust
impl Solution {
    pub fn is_happy(number: i32) -> bool {
        let mut power = 1;
        let mut lam = 1;
        let mut tortoise = Self::get_next_happy(number);
        let mut hare = Self::get_next_happy(Self::get_next_happy(number));

        while tortoise != hare {
            if power == lam {
                tortoise = hare;
                power *= 2;
                lam = 0;
            }
            hare = Self::get_next_happy(hare);
            lam += 1;
        }

        hare = Self::get_next_happy(number);
        tortoise = Self::get_next_happy(number);
        for _ in 0..lam {
            hare = Self::get_next_happy(hare);
        }

        while tortoise != hare {
            tortoise = Self::get_next_happy(tortoise);
            hare = Self::get_next_happy(hare);
        }

        hare == 1
    }

    fn get_next_happy(mut number: i32) -> i32 {
        let mut sum = 0;
        while number > 0 {
            let digit = number % 10;
            sum += digit * digit;
            number /= 10;
        }
        sum
    }
}

```


### println!

```
// n = 2 μΌλ• 

Happy slow_n:1 fast_n:3
Happy slow_n:2 fast_n:5
Happy slow_n:3 fast_n:7
Happy slow_n:4 fast_n:9
Happy slow_n:5 fast_n:11
Happy slow_n:6 fast_n:13
Happy slow_n:7 fast_n:15
```


### javascript
```js
function isHappy(number) {
  let slow = number;
  let fast = getNextHappy(number);

  while (fast !== 1 && slow !== fast) {
    slow = getNextHappy(slow);
    fast = getNextHappy(getNextHappy(fast));
  }

  return fast === 1;
}

function getNextHappy(number) {
  let sum = 0;

  while (number > 0) {
    const digit = number % 10;
    sum += digit ** 2;
    number = Math.floor(number / 10);
  }

  return sum;
}
```


## Answer

#### A1 - `naming convention`
- νƒ€μ… λ λ²¨(type-level)μ—μ„ UpperCamelCase
- κ°’ λ λ²¨(value-level)μ—μ„λ” snake_caseλ¥Ό κ¶μ¥ν•©λ‹λ‹¤.
- λ…λ… κ·μΉ™μ— λ€ν•΄ μμ„Έν μ•μ•„λ³΄λ ¤λ©΄ [μ΄ νμ΄μ§€](https://rust-lang.github.io/api-guidelines/naming.html#naming)λ¥Ό μ°Έμ΅°ν•μ‹­μ‹μ¤.

#### A2 - `u32`
- `u32`λΌλ” 32λΉ„νΈ λ¶€νΈ μ—†λ” μ •μν•μ΄ λ‚΄μ¥λμ–΄ μμµλ‹λ‹¤.
- λ°μ΄ν„° νƒ€μ…μ— λ€ν•΄ λ” μμ„Έν μ•μ•„λ³΄λ ¤λ©΄ [μ΄ νμ΄μ§€](https://rinthel.github.io/rust-lang-book-ko/ch03-02-data-types.html#%EC%A0%95%EC%88%98%ED%98%95)λ¥Ό μ°Έμ΅°ν•μ‹­μ‹μ¤.
- `u128`μ— λ€ν•΄μ„λ” GPTμ—μ„λ” Rustμ— μ΅΄μ¬ν•λ‹¤κ³  λ§ν•μ§€λ§ κ³µμ‹ λ¬Έμ„μ—μ„λ” ν™•μΈν•  μ μ—†μµλ‹λ‹¤.

#### Q3 - `Self::`
- 

#### A4 - `Rust μ—°μ‚°μ`
μμ£Ό μ‚¬μ©ν•λ” μ—°μ‚°μ μ¤‘ μΌλ¶€λ” λ‹¤μκ³Ό κ°™μµλ‹λ‹¤:
- μ‚°μ  μ—°μ‚°μ: `+`, `-`, `*`, `/`, `%`
- λΉ„νΈ μ—°μ‚°μ: `&`, `|`, `^`, `!`, `<<`, `>>`
- λ…Όλ¦¬ μ—°μ‚°μ: `&&`, `||`, `!`
- λ€μ… μ—°μ‚°μ: `=`, `+=`, `-=`, `*=`, `/=`, `%=`
- λΉ„κµ μ—°μ‚°μ: `==`, `!=`, `<`, `>`, `<=`, `>=`
- λ²”μ„ μ—°μ‚°μ: `..`, `...`
- μ°Έμ΅° μ—°μ‚°μ: `&`, `&mut`

μ¶”κ°€: `&String`κ³Ό `&str`μ— λ€ν•΄μ„λ” [μ΄ κΈ°μ‚¬](https://blog.logrocket.com/understanding-rust-string-str/)μ—μ„ μ΄ λ‘ νƒ€μ… κ°„μ μ°¨μ΄μ μ„ λ” μμ„Έν μ•μ•„λ³Ό μ μμµλ‹λ‹¤.